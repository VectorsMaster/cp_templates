//// fixed base
LL n,x,y,z,l,r,h;
vector <pair<LL,LL>> events;
multiset <LL> s;
scl(n);
for(int i=1;i<=n;i++){
    scl(l);scl(r);scl(h);
    events.pb({l,h});
    events.pb({r,-h});
}
LL sum=0;
sort(all(events));
LL lst=0;
for(auto x:events){
    if(s.size()>0){
        LL p=*(s.begin());
        p*=-1;
        sum+= p*(x.F-lst);
    }
    if(x.S>0)s.insert(-x.S);
    else s.erase(s.find(x.S));
    lst=x.F;
}
cout<<sum<<endl;
// unfixedbase
struct rect{
    int v1,u1,v2,u2;
};
int mn[4*KL],cnt[4*KL],lazy[4*KL],n;
pair<int,int> solve(pair<int,int> a,pair<int,int> b){
    if(a.F==b.F)return {a.F,b.S+a.S};
    if(a.F<b.F)return a;
    return b;
}
void build(int cur=1,int st=0,int en=1e5){
    if(st==en){cnt[cur]=1;mn[cur]=0;lazy[cur]=0;}
    else {
        int mid=(st+en)/2;
        build(2*cur,st,mid);
        build(2*cur+1,mid+1,en);
        pair<int,int> ret=solve({mn[2*cur],cnt[2*cur]},{mn[2*cur+1],cnt[2*cur+1]});
        mn[cur]=ret.F;cnt[cur]=ret.S;
        lazy[cur]=0;
    }
}
void push(int cur,int st,int en){
    int mid=(st+en)/2;
    if(lazy[cur]!=0){
        lazy[2*cur]+=lazy[cur];
        lazy[2*cur+1]+=lazy[cur];
        mn[2*cur]+=lazy[cur];
        mn[2*cur+1]+=lazy[cur];
        lazy[cur]=0;
    }
}
void update(int val,int l,int r,int cur=1,int st=0,int en=1e5){
    if(l>en || r<st)return;
    if(l<=st && en<=r){
        mn[cur]+=val;
        lazy[cur]+=val;
        return;
    }
    push(cur,st,en);
    int mid=(st+en)/2;
    update(val,l,r,2*cur,st,mid);
    update(val,l,r,2*cur+1,mid+1,en);
    pair<int,int> ret=solve({mn[2*cur],cnt[2*cur]},{mn[2*cur+1],cnt[2*cur+1]});
    mn[cur]=ret.F;cnt[cur]=ret.S;
}
vector <pair<int,int>> op[KL],of[KL];
vector <int> events;
bool ok[KL];
LL area(vector <rect> a){
    build();
    for(auto rc:a){
        op[rc.v1].pb({rc.u1,rc.u2});
        of[rc.v2].pb({rc.u1,rc.u2});
        if(!ok[rc.v1]){
            events.pb(rc.v1);
            ok[rc.v1]=1;
        }
        if(!ok[rc.v2]){
            events.pb(rc.v2);
            ok[rc.v2]=1;
        }
    }
    sort(all(events));
    //inrow(events);cout<<endl;
    int lst=events[0];
    LL sum=0;
    for(auto x:events){
        LL tt=1e5+1;
        if(mn[1]==0)tt-=(LL)cnt[1];

        sum+=tt*(LL)(x-lst);
        //cout<<sum<<" "<<x<<" "<<tt<<endl;
        for(auto y:op[x]){update(1,y.F,y.S-1);}
        for(auto y:of[x])update(-1,y.F,y.S-1);
        lst=x;
        ok[x]=0;
        op[x].clear();
        of[x].clear();
    }
    events.clear();
    return sum;
}